var React 	= require('react');
var _ = require('lodash');

//takes node and edge data and out node and edge svgs

//commence dreamcode
var Cola = require('webcola-adaptor')();
var Node 		= require('node-ui');
var Edge 		= require('edge-ui');

module.exports = React.createClass({

	getInitialState: function (options) {
		var predicates = this.props.predicates || []; //
		var edges = [];
		var	entities = this.props.entities;

		entities.forEach(function (entity, i) { entity.index = i });

		//compute links
		for (var i=0;i<entities.length;i++) {
			var entity = entities[i];
			for(var j=0;j<predicates.length;j++) {
				var predicate = predicates[j];
				if(typeof entity[predicate] !== 'undefined') {
					var target = _.find(entities, { id: entity[predicate] });
					edges.push(
						{
							source: entity.index,
							target: target.index,
							type: predicate
						}
					);
				}
			}
		}


		var width 	= 400,
				height 	= 400;

		var cola = Cola
			.size([width, height])
			.avoidOverLaps(true)
			.nodes(entities)
			.links(edges)

		return {
			cola: cola,
			nodes: cola.nodes()
		}
	}


	render: function () {

		var nodes = this.state.nodes;
		var edges = this.state.cola.links();


		return(
			<div>
				<svg 
					width={this.props.width}
					height={this.props.height}
					<g className='node-group'>
						{
							nodes.map(function (node) {
								return <Node datum={node} actions={actions} />
							});
						}.bind(this);
					</g>
					<g className='edge-group'>
						{
							edges.map(function (edge) {
								return <Edge datum={edge} actions={actions} />
							});
						}.bind(this);
					</g>
				</svg>
			</edge>
		);
	},

	componentDidMount: function () {

		//tick listener triggers setState, trigger rerender
		this.state.cola.on('tick', function () {
			this.setState({ nodes: this.state.cola.nodes() })
		});


		//trigget force graph
		this.state.cola.start();


	},


	shouldComponentUpdate: function (nextProps, nextState) {
		//TODO use immutable.js
		//Test if new data recieved, if true rerender
		// if (nextProps.nodes === this.props.nodes 
		// 		|| nextProps.edges === this.props.edges) return false;
		// else return true;
		return true;
	},

	componentWillUpdate: function (nextProps, nextState) {




	},





})

